# Final Project Reflection – FastAPI User Calculations

For the final project, I extended my Module 14 FastAPI application by adding a complete **Profile & Password Management** feature. Instead of just building new routes in isolation, I wanted the feature to touch every layer of the stack: database models, Pydantic schemas, FastAPI routers, HTML/JavaScript, automated tests, Docker, and CI. This helped me practice how a real production feature usually grows across multiple files and concerns.

On the backend, I created a new `/profile` router that lets a user load their profile, update their email or full name, and change their password. All of these actions require the current password, which is validated against the bcrypt hash stored in the database. Implementing this reminded me why security has to be built into the design from the beginning. It also reinforced how SQLAlchemy sessions, models, and Pydantic schemas fit together to safely update a single `User` row without breaking other parts of the application.

I also wrote new **integration tests** and **Playwright E2E tests** that follow the full flow: create a known user, read the profile, update the profile, rotate the password, and verify the old password no longer works. These tests showed me how valuable it is to automate not just happy paths but also transitions, like “old credentials fail, new credentials succeed.” Because the tests cover both the API and the browser UI, I had to be careful with response messages, field IDs, and error handling so everything stayed consistent end-to-end.

Finally, I verified that the new feature still works with my existing **Docker** and **GitHub Actions** setup. The CI pipeline installs dependencies, runs all tests (including Playwright), builds the Docker image, and pushes it to Docker Hub when the branch is healthy. Seeing the entire workflow succeed—with the new profile functionality included—gave me confidence that I can add meaningful features to a Python/FastAPI codebase while respecting testing, security, and DevOps practices. Overall, this final project tied together many course learning outcomes: REST APIs, SQL databases, JSON validation with Pydantic, authentication and hashing, automated testing, CI/CD, and containerization.
